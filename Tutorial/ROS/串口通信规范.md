# 串口通信规范


## 串口模式

- 波特率：57600
- 数据位：8
- 奇偶校验：偶校验
- 停止位：1

接收端2ms速度轮询（因为最长的消息需要2.9ms传输完成）；如果有循环发送需求的话，发送端5ms速度循环发送，需要等待发送缓冲区flush。

## 消息规范

### 1. 启动信号
发送端发出`0x55 0xaa`两个字节，标识串口通信开始。

### 2. 发送数据类型
由于Arduino要接收Twist消息和推杆信息两种信息，约定发送一个字节，标识数据类型：
- Twist: `0xa0`
- 推杆信息: `0xa1`

Arduino只需要发出action这一种信息，因此不需要标识数据类型。
<!-- Arduino只需要发出里程计（Odom）这一种信息，因此不需要标识数据类型。 -->

### 3. 数据本体
Arduino和上位机树莓派、PC都是IEEE 754型浮点数、小端序，不过Arduino的double实际上是float。因此，两方可以从小端到大端逐字节直接发送接收二进制数据。

#### Twist
由于我们在平面上运动，Twist只需要收发
- linear_x
- linear_y
- angular_z

这三种数据。照顾到Arduino没有double型数据，两方都发送float，按以上顺序收发这三个float，共12字节。

#### 推杆信息
只有一个bool型，指示是否给推杆供电。

#### action信息
只有一个bool型，指示倾倒是否完成。

#### 里程计Odom
包含五个信息：
- x_final
- y_final
- th_final
- velocity1
- velocity2

同样都是float，按以上顺序发送。

### 4. 校验码
在数据本体发送完毕后，发送两字节的校验码，第一个字节内容是之前发送的所有字节的异或，第二个字节的内容是之前发送的左右字节的加和（不包括第一个字节校验码）。

> 例如，Arduino接收到的一个推杆伸出的信息是：
> `0x55 0xaa 0xa1 0x01`，
> 那么它接下来要接收到两个校验码，第一个是
> `0x55 ^ 0xaa ^ 0xa1 ^ 0x01 = 0x5f`，
> 第二个是
> `0x55 + 0xaa + 0xa1 + 0x01 = 0xa1`，
> 两个校验码无误才能确认接收消息。

## 错误处理规范

### 接收方
接收方轮询的具体操作方法是，每次调用轮询，用一个循环读取，一个字节一个字节读取，直到将串口缓冲区读空，读空后退出轮询函数。注意，轮询函数一次调用不一定能完整读取一条消息，因此内部需要用一个线性状态机处理。

首先，标志变量置-3。

当标志位为-3时，若串口输入`0x55`时，标志位改-2，否则，维持-3。

当标志位为-2时，若串口输入`0xaa`时，标志位改-1，否则，标志位改回-3。

当标志位为-1时，若串口输入`0xa0`时，进入Twist读取模式，标志位改0；若串口输入为`0xa1`时，进入推杆读取模式，标志位改0；否则，标志位改回-3。
需要另起一个标志位，记录当前是Twist读取模式还是推杆读取模式。

在Twist读取模式下，读取12个字节，标志位从0增加到12。
当标志位为12时，核验本地计算的异或校验码是否和传入的异或校验码一致，一致则标志位改13，否则标志位改-3，并清空串口读取缓冲区，因为可能发生了数据错位的情况。
当标志位为13时，核验本地的加和校验码是否与传入一致，一致则宣告读取成功，标志位归-3，否则标志位也归-3，但需清空串口读取缓冲区。

在推杆读取模式下，同理。

### 发送端
监测串口是否断联（Serial::IOException），如是，循环重开串口。